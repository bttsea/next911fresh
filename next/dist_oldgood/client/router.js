"use strict";exports.__esModule=true;exports.default=exports.createRouter=void 0;exports.makePublicRouterInstance=makePublicRouterInstance;exports.useRouter=useRouter;exports.withRouter=void 0;var _react=_interopRequireDefault(require("react"));var _router2=_interopRequireWildcard(require("../next-server/lib/router/router"));exports.Router=_router2.default;exports.NextRouter=_router2.NextRouter;var _routerContext=require("../next-server/lib/router-context");var _withRouter=_interopRequireDefault(require("./with-router"));exports.withRouter=_withRouter.default;function _interopRequireWildcard(e,t){if("function"==typeof WeakMap)var r=new WeakMap(),n=new WeakMap();return(_interopRequireWildcard=function(e,t){if(!t&&e&&e.__esModule)return e;var o,i,f={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return f;if(o=t?n:r){if(o.has(e))return o.get(e);o.set(e,f);}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((i=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?o(f,t,i):f[t]=e[t]);return f;})(e,t);}function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e};}/* global window */const singletonRouter={router:null,// holds the actual router instance
readyCallbacks:[],ready(cb){if(this.router)return cb();if(typeof window!=='undefined'){this.readyCallbacks.push(cb);}}};// Create public properties and methods of the router in the singletonRouter
const urlPropertyFields=['pathname','route','query','asPath','components'];const routerEvents=['routeChangeStart','beforeHistoryChange','routeChangeComplete','routeChangeError','hashChangeStart','hashChangeComplete'];const coreMethodFields=['push','replace','reload','back','prefetch','beforePopState'];// Events is a static property on the router, the router doesn't have to be initialized to use it
Object.defineProperty(singletonRouter,'events',{get(){return _router2.default.events;}});urlPropertyFields.forEach(field=>{// Here we need to use Object.defineProperty because, we need to return
// the property assigned to the actual router
// The value might get changed as we change routes and this is the
// proper way to access it
Object.defineProperty(singletonRouter,field,{get(){const router=getRouter();return router[field];}});});coreMethodFields.forEach(field=>{// We don't really know the types here, so we add them later instead
;singletonRouter[field]=(...args)=>{const router=getRouter();return router[field](...args);};});routerEvents.forEach(event=>{singletonRouter.ready(()=>{_router2.default.events.on(event,(...args)=>{const eventField=`on${event.charAt(0).toUpperCase()}${event.substring(1)}`;const _singletonRouter=singletonRouter;if(_singletonRouter[eventField]){try{_singletonRouter[eventField](...args);}catch(err){// tslint:disable-next-line:no-console
console.error(`Error when running the Router event: ${eventField}`);// tslint:disable-next-line:no-console
console.error(`${err.message}\n${err.stack}`);}}});});});function getRouter(){if(!singletonRouter.router){const message='No router instance found.\n'+'You should only use "next/router" inside the client side of your app.\n';throw new Error(message);}return singletonRouter.router;}// Export the singletonRouter and this is the public API.
var _default=exports.default=singletonRouter;// Reexport the withRoute HOC
function useRouter(){return _react.default.useContext(_routerContext.RouterContext);}// INTERNAL APIS
// -------------
// (do not use following exports inside the app)
// Create a router and assign it as the singleton instance.
// This is used in client side when we are initilizing the app.
// This should **not** use inside the server.
const createRouter=(...args)=>{singletonRouter.router=new _router2.default(...args);singletonRouter.readyCallbacks.forEach(cb=>cb());singletonRouter.readyCallbacks=[];return singletonRouter.router;};// This function is used to create the `withRouter` router instance
exports.createRouter=createRouter;function makePublicRouterInstance(router){const _router=router;const instance={};for(const property of urlPropertyFields){if(typeof _router[property]==='object'){instance[property]={..._router[property]};// makes sure query is not stateful
continue;}instance[property]=_router[property];}// Events is a static property on the router, the router doesn't have to be initialized to use it
instance.events=_router2.default.events;coreMethodFields.forEach(field=>{instance[field]=(...args)=>{return _router[field](...args);};});return instance;}