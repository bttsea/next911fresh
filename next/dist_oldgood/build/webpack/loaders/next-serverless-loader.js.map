{"version":3,"names":["_path","require","_querystring","_constants","_utils","_constants2","nextServerlessLoader","distDir","absolutePagePath","page","buildId","canonicalBase","assetPrefix","ampBindInitData","absoluteAppPath","absoluteDocumentPath","absoluteErrorPath","generateEtags","query","parse","substr","buildManifest","join","BUILD_MANIFEST","replace","reactLoadableManifest","REACT_LOADABLE_MANIFEST","match","API_ROUTE","isDynamicRoute","_default","exports","default"],"sources":["next-serverless-loader.ts"],"sourcesContent":["import { loader } from 'webpack'\nimport { join } from 'path'\nimport { parse } from 'querystring'\nimport {\n  BUILD_MANIFEST,\n  REACT_LOADABLE_MANIFEST,\n} from '../../../next-server/lib/constants'\nimport { isDynamicRoute } from '../../../next-server/lib/router/utils'\nimport { API_ROUTE } from '../../../lib/constants'\n\nexport type ServerlessLoaderQuery = {\n  page: string\n  distDir: string\n  absolutePagePath: string\n  absoluteAppPath: string\n  absoluteDocumentPath: string\n  absoluteErrorPath: string\n  buildId: string\n  assetPrefix: string\n  ampBindInitData: boolean | string\n  generateEtags: string\n  canonicalBase: string\n}\n\nconst nextServerlessLoader: loader.Loader = function() {\n  const {\n    distDir,\n    absolutePagePath,\n    page,\n    buildId,\n    canonicalBase,\n    assetPrefix,\n    ampBindInitData,\n    absoluteAppPath,\n    absoluteDocumentPath,\n    absoluteErrorPath,\n    generateEtags,\n  }: ServerlessLoaderQuery =\n    typeof this.query === 'string' ? parse(this.query.substr(1)) : this.query\n  const buildManifest = join(distDir, BUILD_MANIFEST).replace(/\\\\/g, '/')\n  const reactLoadableManifest = join(distDir, REACT_LOADABLE_MANIFEST).replace(\n    /\\\\/g,\n    '/'\n  )\n\n  if (page.match(API_ROUTE)) {\n    return `\n    ${\n      isDynamicRoute(page)\n        ? `\n      import { getRouteMatcher } from 'next/dist/next-server/lib/router/utils/route-matcher';\n      import { getRouteRegex } from 'next/dist/next-server/lib/router/utils/route-regex';\n      `\n        : ``\n    }\n      import { parse } from 'url'\n      import { apiResolver } from 'next/dist/next-server/server/api-utils'\n\n      export default (req, res) => {\n        const params = ${\n          isDynamicRoute(page)\n            ? `getRouteMatcher(getRouteRegex('${page}'))(parse(req.url).pathname)`\n            : `{}`\n        }\n        const resolver = require('${absolutePagePath}')\n        apiResolver(req, res, params, resolver)\n      }\n    `\n  } else {\n    return `\n    import {parse} from 'url'\n    import {renderToHTML} from 'next/dist/next-server/server/render';\n    import {sendHTML} from 'next/dist/next-server/server/send-html';\n    ${\n      isDynamicRoute(page)\n        ? `import {getRouteMatcher, getRouteRegex} from 'next/dist/next-server/lib/router/utils';`\n        : ''\n    }\n    import buildManifest from '${buildManifest}';\n    import reactLoadableManifest from '${reactLoadableManifest}';\n    import Document from '${absoluteDocumentPath}';\n    import Error from '${absoluteErrorPath}';\n    import App from '${absoluteAppPath}';\n    import * as ComponentInfo from '${absolutePagePath}';\n    const Component = ComponentInfo.default\n    export default Component\n    export const unstable_getStaticProps = ComponentInfo['unstable_getStaticProp' + 's']\n    ${\n      isDynamicRoute(page)\n        ? \"export const unstable_getStaticParams = ComponentInfo['unstable_getStaticParam' + 's']\"\n        : ''\n    }\n    export const config = ComponentInfo['confi' + 'g'] || {}\n    export const _app = App\n    export async function renderReqToHTML(req, res, fromExport) {\n      const options = {\n        App,\n        Document,\n        buildManifest,\n        unstable_getStaticProps,\n        reactLoadableManifest,\n        canonicalBase: \"${canonicalBase}\",\n        buildId: \"${buildId}\",\n        assetPrefix: \"${assetPrefix}\",\n        ampBindInitData: ${ampBindInitData === true ||\n          ampBindInitData === 'true'},\n      }\n      let sprData = false\n\n      if (req.url.match(/_next\\\\/data/)) {\n        sprData = true\n        req.url = req.url\n          .replace(/\\\\/_next\\\\/data\\\\//, '/')\n          .replace(/\\\\.json$/, '')\n      }\n      const parsedUrl = parse(req.url, true)\n      const renderOpts = Object.assign(\n        {\n          Component,\n          pageConfig: config,\n          dataOnly: req.headers && (req.headers.accept || '').indexOf('application/amp.bind+json') !== -1,\n          nextExport: fromExport\n        },\n        options,\n      )\n      try {\n        ${page === '/_error' ? `res.statusCode = 404` : ''}\n        ${\n          isDynamicRoute(page)\n            ? `const params = fromExport && !unstable_getStaticProps ? {} : getRouteMatcher(getRouteRegex(\"${page}\"))(parsedUrl.pathname) || {};`\n            : `const params = {};`\n        }\n        const result = await renderToHTML(req, res, \"${page}\", Object.assign({}, unstable_getStaticProps ? {} : parsedUrl.query, params, sprData ? { _nextSprData: '1' } : {}), renderOpts)\n\n        if (fromExport) return { html: result, renderOpts }\n        return result\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          res.statusCode = 404\n          const result = await renderToHTML(req, res, \"/_error\", parsedUrl.query, Object.assign({}, options, {\n            Component: Error\n          }))\n          return result\n        } else {\n          console.error(err)\n          res.statusCode = 500\n          const result = await renderToHTML(req, res, \"/_error\", parsedUrl.query, Object.assign({}, options, {\n            Component: Error,\n            err\n          }))\n          return result\n        }\n      }\n    }\n    export async function render (req, res) {\n      try {\n        const html = await renderReqToHTML(req, res)\n        sendHTML(req, res, html, {generateEtags: ${generateEtags}})\n      } catch(err) {\n        console.error(err)\n        res.statusCode = 500\n        res.end('Internal Server Error')\n      }\n    }\n  `\n  }\n}\n\nexport default nextServerlessLoader\n"],"mappings":"4DACA,IAAAA,KAAA,CAAAC,OAAA,SACA,IAAAC,YAAA,CAAAD,OAAA,gBACA,IAAAE,UAAA,CAAAF,OAAA,uCAIA,IAAAG,MAAA,CAAAH,OAAA,0CACA,IAAAI,WAAA,CAAAJ,OAAA,2BAgBA,KAAM,CAAAK,oBAAmC,CAAG,QAAAA,CAAA,CAAW,CACrD,KAAM,CACJC,OAAO,CACPC,gBAAgB,CAChBC,IAAI,CACJC,OAAO,CACPC,aAAa,CACbC,WAAW,CACXC,eAAe,CACfC,eAAe,CACfC,oBAAoB,CACpBC,iBAAiB,CACjBC,aACqB,CAAC,CACtB,MAAO,KAAI,CAACC,KAAK,GAAK,QAAQ,CAAG,GAAAC,kBAAK,EAAC,IAAI,CAACD,KAAK,CAACE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAG,IAAI,CAACF,KAAK,CAC3E,KAAM,CAAAG,aAAa,CAAG,GAAAC,UAAI,EAACf,OAAO,CAAEgB,yBAAc,CAAC,CAACC,OAAO,CAAC,KAAK,CAAE,GAAG,CAAC,CACvE,KAAM,CAAAC,qBAAqB,CAAG,GAAAH,UAAI,EAACf,OAAO,CAAEmB,kCAAuB,CAAC,CAACF,OAAO,CAC1E,KAAK,CACL,GACF,CAAC,CAED,GAAIf,IAAI,CAACkB,KAAK,CAACC,qBAAS,CAAC,CAAE,CACzB,MAAO;AACX,MACM,GAAAC,qBAAc,EAACpB,IAAI,CAAC,CAChB;AACV;AACA;AACA,OAAO,CACG,EAAE;AACZ;AACA;AACA;AACA;AACA,yBAEU,GAAAoB,qBAAc,EAACpB,IAAI,CAAC,CAChB,kCAAkCA,IAAI,8BAA8B,CACpE,IAAI;AAClB,oCACoCD,gBAAgB;AACpD;AACA;AACA,KAAK,CACH,CAAC,IAAM,CACL,MAAO;AACX;AACA;AACA;AACA,MACM,GAAAqB,qBAAc,EAACpB,IAAI,CAAC,CAChB,wFAAwF,CACxF,EAAE;AACZ,iCACiCY,aAAa;AAC9C,yCAAyCI,qBAAqB;AAC9D,4BAA4BV,oBAAoB;AAChD,yBAAyBC,iBAAiB;AAC1C,uBAAuBF,eAAe;AACtC,sCAAsCN,gBAAgB;AACtD;AACA;AACA;AACA,MACM,GAAAqB,qBAAc,EAACpB,IAAI,CAAC,CAChB,wFAAwF,CACxF,EAAE;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAC0BE,aAAa;AACvC,oBAAoBD,OAAO;AAC3B,wBAAwBE,WAAW;AACnC,2BAA2BC,eAAe,GAAK,IAAI,EACzCA,eAAe,GAAK,MAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAUJ,IAAI,GAAK,SAAS,CAAG,sBAAsB,CAAG,EAAE;AAC1D,UACU,GAAAoB,qBAAc,EAACpB,IAAI,CAAC,CAChB,+FAA+FA,IAAI,gCAAgC,CACnI,oBAAoB;AAClC,uDACuDA,IAAI;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmDQ,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,CACD,CACF,CAAC,KAAAa,QAAA,CAAAC,OAAA,CAAAC,OAAA,CAEc1B,oBAAoB","ignoreList":[]}